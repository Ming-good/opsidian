## 인증서란?
- **서버가 신뢰할 수 있는 진짜 서버 임을 확인**하기 위해 필요한 것이 바로   **인증서**이다.
- 서버 공개키 + CA 비밀키 암호화 = 인증서

# 인증서 발급 과정
![[Pasted image 20240910131929.png]]


# CA 인증서 인증 과정
![[Pasted image 20240910142812.png]]

# Handshake 
- 클라이언트는 서버의 공개키로 데이터 암호화에 사용할 대칭키를 암호화여 서버로 전달함으로써 **서버의 무결성**을 검증을 한다.
- 이외에도 TLS version 확인하고 암호화 방식, 해시 방식을 협상한다. (인터페이스 동기화 과정)
#### 1. **ClientHello (클라이언트의 요청)**
- **클라이언트**가 서버에 접속하려고 할 때, 클라이언트는 **ClientHello** 메시지를 보냅니다. 이 메시지에는 클라이언트가 지원하는 **암호화 방식(알고리즘)**, **SSL/TLS 버전**, 그리고 **임의의 난수**가 포함됩니다.
- 이 메시지는 서버에게 클라이언트의 의도를 알리고, 통신에 사용할 보안 매개변수를 협상하는 초기 단계입니다.

#### 2. **ServerHello (서버의 응답)**
- **서버**는 클라이언트의 **ClientHello** 메시지를 받고, 자신이 지원하는 암호화 방식 중 하나를 선택한 뒤, **ServerHello** 메시지를 보냅니다. 이 메시지에는 서버가 선택한 **암호화 방식**, **자신의 인증서**(공개키가 포함된), 그리고 **임의의 난수**가 포함됩니다.

#### 3. **인증서 검증 및 대칭키 생성**
- **클라이언트**는 서버로부터 받은 인증서를 통해 서버의 **공개키**를 얻고, 인증서의 신뢰성을 검증합니다(CA 서명 검증).
- 클라이언트는 안전한 통신을 위해 **대칭키**(세션 키)를 생성하고, 이 대칭키를 서버의 **공개키**로 암호화한 뒤 서버에 전송합니다. 이 과정이 대칭키 교환의 핵심입니다.
    - 이때 암호화된 대칭키는 서버의 공개키로 암호화되어, 오직 서버만 자신의 비밀키로 복호화할 수 있습니다.
- 이 대칭키는 이후 클라이언트와 서버가 주고받는 데이터를 암호화하는 데 사용됩니다.

#### 4. **서버의 대칭키 복호화**
- **서버**는 자신의 **비밀키**를 사용해 클라이언트가 보낸 대칭키(세션 키)를 복호화합니다.
- 이로써 서버와 클라이언트는 **같은 대칭키**를 공유하게 되며, 이후의 통신은 이 대칭키를 사용해 암호화됩니다.

#### 5. **Finish 메시지**
- 양쪽 모두 안전한 대칭키를 공유한 상태에서, 클라이언트와 서버는 서로 **Finish** 메시지를 보내 통신 준비가 완료되었음을 알립니다.
- 이때부터 클라이언트와 서버는 대칭키를 사용해 안전하게 데이터를 주고받게 됩니다.

#### 정리: 핸드쉐이크는 대칭키를 전달하는 과정의 일부
핸드쉐이크는 **대칭키를 안전하게 교환**하는 것 외에도, 다음을 포함한 과정입니다:

- 클라이언트와 서버 간의 보안 매개변수 협상 (암호화 방식 선택).
- 서버 인증서의 신뢰성 검증 (CA 서명 검증).
- **대칭키 교환**: 클라이언트가 생성한 대칭키(세션 키)를 서버의 공개키로 암호화하여 전달.
- 이후 대칭키를 사용한 안전한 통신 시작.

#### **SESSION ID**
최초 한번의 Handshake만 Full Handshake를 하기로 하자! 해서 사용하는 것이 Session ID 입니다.
![[Pasted image 20240910150707.png]]

#### **SNI(Server Name Indication)**
- SNI(서버 이름 표시)는 하나의 IP 주소에 여러 도메인을 연결할 때, 각 도메인마다 다른 TLS 인증서를 사용할 수 있도록 도와줍니다.
- SNI는 서버에 접속할 때 어떤 도메인에 접속하는지 명시하는 역할을 합니다.
- 문제점은 SNI가 평문으로 전송되기 때문에 도메인이 노출될 수 있다는 점입니다.
- TLS 1.3에서는 SNI를 암호화해 이 문제를 해결하려는 시도가 있습니다.