## 락 기반 알고리즘의 문제점

Mutex, Semaphore나 를 이용한 Lock을 통해 멀티스레드를 관리할 때에는 **Lock을 획득하지 못한 스레드**는 Lock을 획득한 스레드가 해당 Lock을 Release 할때까지 **대기상태에 머물러야 한다는 단점**이 있음. 또 DeadLock과 같은 예상하지 못한 문제가 발생할 수도 있다.

한마디로 일반적으로 Lock 사용 시 공유 메모리에 접근하는 멀티쓰레드가 많아질수록 성능이 오히려 떨어지게 되는 문제점 발생 한다는 뜻이다.

## 락 프리(Lock-Free) 알고리즘

**락 프리(Lock-Free)란?** 여러 개의 쓰레드에서 동시 호출하더라도 특정 단위 시간에는 적어도 한개의 호출이 완료되는 알고리즘이라고 정의할 수 있다. 즉, 다른 쓰레드의 상태에 상관 없이 적어도 하나의 쓰레드의 호출은 완료된다는 뜻이다.
#### 락프리 알고리즘 원리
- 공유 메모리 변수의 값을 일단 변경하고 해당 값이 맞는지 확인하는 방법이다. 만약 값을 변경하는 동안 다른 스레드에서 간섭이 있었는지를 확인하고 만약 간섭이 있었다면 그에 대한 처리를 해주면 된다.
- 여기에 사용되는 연산이 **CAS(Compare And Swap - 읽고 비교하교 쓰는)** 연산으로 최근 거의 모든 프로세스에서 CAS 연산을 단일 연산으로 Atomic하게 동작하도록 지원하고 있다. 
```
- JAVA 

private final AtomicLong availableTokens = new AtomicLong(); 
private final AtomicLong lastRefillTime = new AtomicLong(); 
```
ㄹ