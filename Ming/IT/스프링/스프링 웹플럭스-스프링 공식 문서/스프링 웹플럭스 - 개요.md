[Overview :: Spring Framework](https://docs.spring.io/spring-framework/reference/web/webflux/new-framework.html)


**왜 Spring WebFlux가 만들어졌는가?**

Spring WebFlux는 소수의 스레드로 동시성을 처리하고 적은 하드웨어 자원으로 확장할 수 있는 **논블로킹 웹 스택**의 필요성에서 탄생했습니다. 서블릿의 논블로킹 I/O는 동기적(예: `getParameter`, `getPart`) 또는 블로킹(예: `Filter`, `Servlet`) 계약을 사용하는 기존 서블릿 API와 거리가 있습니다. 이에 따라 모든 논블로킹 런타임에서 사용할 수 있는 새로운 공통 API가 필요했습니다. 이는 Netty와 같은 논블로킹 환경에서 널리 사용되는 서버를 지원하기 위해 중요합니다.

다른 이유는 **함수형 프로그래밍**입니다. Java 5의 애노테이션 추가가 애노테이션 기반 REST 컨트롤러나 유닛 테스트 같은 기회를 제공했듯이, Java 8의 람다 표현식은 Java에서 함수형 API를 개발할 기회를 열었습니다. 이는 논블로킹 애플리케이션과 선언적 비동기 로직 구성을 가능하게 하는 **ReactiveX**와 **CompletableFuture** 스타일 API에 유리합니다. Java 8은 Spring WebFlux가 애노테이션 기반 컨트롤러와 함께 함수형 웹 엔드포인트를 제공할 수 있게 했습니다.

---

### **Reactive란 무엇인가?**

**논블로킹**과 **함수형**이라는 키워드 외에, Reactive의 의미는 무엇일까요?

Reactive는 변화에 반응하는 프로그래밍 모델을 뜻합니다. 네트워크 컴포넌트가 I/O 이벤트에 반응하거나, UI 컨트롤러가 마우스 이벤트에 반응하는 것처럼, **Reactive는 변화에 반응하는 것을 기반으로 합니다**. 이런 관점에서 논블로킹은 Reactive의 일종이라 할 수 있습니다. 기존 방식에서 스레드가 블로킹되었다면, 이제는 작업 완료나 데이터 가용성에 대한 알림에 반응하는 방식으로 동작합니다.

또 다른 중요한 Reactive 메커니즘은 **논블로킹 백프레셔(Back Pressure)**입니다. 동기적 명령형 코드에서는 블로킹 호출이 자연스러운 백프레셔 역할을 해 호출자가 대기하도록 강제합니다. 반면, 논블로킹 코드에서는 이벤트 발생 속도를 제어해 빠른 생산자가 데이터를 소비할 수 있는 속도를 초과하지 않도록 해야 합니다.

Reactive Streams는 Java 9에서도 채택된 작은 스펙으로, 백프레셔를 고려해 비동기 컴포넌트 간의 상호작용을 정의합니다. 예를 들어, 데이터 저장소(Publisher 역할)가 데이터를 생성하면 HTTP 서버(Subscriber 역할)가 이를 받아 응답으로 처리합니다. Reactive Streams의 주된 목적은 Subscriber가 Publisher의 데이터 생성 속도를 제어할 수 있게 하는 것입니다.

> **참고**  
> 자주 묻는 질문: Publisher가 속도를 늦출 수 없다면 어떻게 해야 하나요?  
> Reactive Streams는 메커니즘과 경계를 설정하는 데 목적이 있습니다. Publisher가 속도를 늦출 수 없는 경우 버퍼링, 데이터 드롭, 또는 실패 처리 방식을 선택해야 합니다.

---

### **Reactive API**

Reactive Streams는 [[상호 운용성]]을 위해 중요합니다. 이는 라이브러리와 인프라 컴포넌트에 유용하지만, 애플리케이션 API로는 너무 저수준이어서 적합하지 않습니다. 애플리케이션에서는 Java 8의 `Stream` API와 유사하지만 컬렉션에 국한되지 않은 고수준의 [[함수형 API]]가 필요합니다. Reactive 라이브러리는 이러한 요구를 해결합니다.

Spring WebFlux에서 선택한 Reactive 라이브러리는 **Reactor**입니다. Reactor는 `Mono`와 `Flux`라는 API 타입을 제공해 각각 0~1개(`Mono`), 0~N개(`Flux`)의 데이터 시퀀스를 처리합니다. 이 API는 ReactiveX의 연산자 어휘에 맞춰 설계된 풍부한 연산자를 지원합니다. Reactor는 Reactive Streams 라이브러리로, 모든 연산자가 [[논블로킹 백프레셔]]를 지원합니다. Reactor는 서버 측 Java에 초점을 맞춰 개발되었으며 Spring과 긴밀히 협력하여 발전해 왔습니다.

WebFlux는 Reactor를 핵심 의존성으로 사용하지만, Reactive Streams를 통해 다른 Reactive 라이브러리와도 상호 운용됩니다. 일반적으로 WebFlux API는 `Publisher`를 입력으로 받아 내부적으로 Reactor 타입으로 변환한 뒤, `Mono` 또는 `Flux`로 반환합니다. 따라서, 어떤 `Publisher`도 입력으로 전달할 수 있고 출력에서 연산을 적용할 수 있지만, 다른 Reactive 라이브러리를 사용할 경우 출력 값을 변환해야 합니다. 애노테이션 기반 컨트롤러 같은 경우 WebFlux는 RxJava나 다른 Reactive 라이브러리의 사용을 자동으로 처리합니다. 자세한 내용은 [Reactive Libraries](https://spring.io/)를 참고하십시오.

> **참고**  
> Reactive API 외에도 WebFlux는 Kotlin의 Coroutines API와 함께 사용할 수 있습니다. 이는 더 명령형 스타일의 프로그래밍을 제공합니다. 다음 예제는 Coroutines API를 사용하는 Kotlin 코드 샘플을 포함합니다.

---

### **프로그래밍 모델**

Spring WebFlux는 다음 두 가지 프로그래밍 모델을 제공합니다.

1. **애노테이션 컨트롤러**:  
    Spring MVC와 일관성을 유지하며, `spring-web` 모듈의 동일한 애노테이션(@RequestBody 등)을 기반으로 합니다. Spring MVC와 WebFlux 컨트롤러 모두 Reactive 리턴 타입(Reactor 및 RxJava)을 지원하므로, 두 모델을 구분하기 쉽지 않을 수 있습니다. 그러나 WebFlux는 Reactive 매개변수도 지원한다는 점에서 차이가 있습니다.
    
2. **[[함수형 엔드포인트]]**:  
    람다 기반으로 경량화된 함수형 프로그래밍 모델입니다. 이는 요청을 라우팅하고 처리하기 위해 애플리케이션이 사용할 수 있는 유틸리티 집합으로 볼 수 있습니다. 애노테이션 컨트롤러와의 주요 차이는, 함수형 엔드포인트에서는 요청 처리를 처음부터 끝까지 애플리케이션이 제어한다는 점입니다.
    

---

### **적용 사례**

**Spring MVC와 WebFlux 중 무엇을 선택해야 할까요?**

자연스러운 질문이지만, 이는 잘못된 이분법을 전제합니다. 사실 이 두 가지는 서로 협력해 사용 가능한 옵션의 범위를 확장합니다. 
Spring MVC와 WebFlux는 서로 간의 연속성과 일관성을 고려해 설계되었으며, 동시에 사용할 수 있습니다.  또한, 각 방식에서 얻은 피드백은 서로에게 이점을 제공합니다. 
아래 다이어그램은 이 두 기술 간의 관계, 공통점, 그리고 각 기술이 고유하게 지원하는 기능을 보여줍니다:

![[Pasted image 20250121163258.png]]

- **Spring MVC 애플리케이션이 잘 동작하고 있다면 변경할 필요가 없습니다.**  
    명령형 프로그래밍은 코드를 작성하고 이해하며 디버깅하기 가장 쉬운 방법입니다. 또한, 대부분의 라이브러리가 기존에 차단(Blocking) 방식으로 개발되었기 때문에, 선택할 수 있는 라이브러리의 범위가 가장 넓습니다.
    
- **논블로킹 웹 스택을 고려하고 있다면 Spring WebFlux를 선택하세요.**  
    Spring WebFlux는 이 영역의 다른 프레임워크들과 동일한 실행 모델의 이점을 제공하며, 서버(Netty, Tomcat, Jetty, Undertow, Servlet 컨테이너), 프로그래밍 모델(애너테이션 기반 컨트롤러, 함수형 웹 엔드포인트), 리액티브 라이브러리(Reactor, RxJava 등)를 선택할 수 있는 유연성을 제공합니다.
    
- **Java 8 람다나 Kotlin을 활용한 경량의 함수형 웹 프레임워크를 찾고 있다면,**  
    Spring WebFlux의 함수형 웹 엔드포인트를 사용할 수 있습니다. 이 접근 방식은 간단한 애플리케이션이나 복잡한 요구사항이 없는 마이크로서비스에 적합하며, 투명성과 제어성을 높이는 데 유리합니다.
    
- **마이크로서비스 아키텍처에서는 Spring MVC와 Spring WebFlux를 혼합해 사용할 수 있습니다.**  
    Spring MVC 컨트롤러, Spring WebFlux 컨트롤러 또는 Spring WebFlux 함수형 엔드포인트를 조합하여 활용할 수 있습니다. 두 프레임워크가 동일한 애너테이션 기반 프로그래밍 모델을 지원하기 때문에 지식을 재활용하면서도 각 작업에 적합한 도구를 선택하기 용이합니다.
    
- **애플리케이션의 의존성을 확인하여 적합한 선택을 평가하세요.**  
    차단 방식의 영속성 API(JPA, JDBC)나 네트워킹 API를 사용하는 경우, Spring MVC가 일반적인 아키텍처에서 최적의 선택입니다. 기술적으로는 Reactor나 RxJava를 사용해 별도 스레드에서 차단 호출을 수행할 수 있지만, 이는 논블로킹 웹 스택의 장점을 제대로 활용하지 못하는 방식입니다.
    
- **Spring MVC 애플리케이션에서 원격 서비스를 호출하는 경우, 리액티브 WebClient를 활용해 보세요.**  
    Spring MVC 컨트롤러 메서드에서 리액티브 타입(Reactor, RxJava 등)을 직접 반환할 수 있습니다. 호출당 지연 시간이 크거나 호출 간 상호 의존성이 높을수록 리액티브 WebClient의 이점이 더 두드러집니다. 또한, Spring MVC 컨트롤러에서 다른 리액티브 구성 요소를 호출할 수도 있습니다.
    
- **큰 팀의 경우, 논블로킹, 함수형, 선언형 프로그래밍으로 전환하는 데 급격한 학습 곡선을 고려하세요.**  
    완전한 전환 없이 리액티브 WebClient를 먼저 사용하는 것이 실용적인 시작점입니다. 그 이후로는 작은 규모에서 시작해 점진적으로 효과를 측정하는 방식이 좋습니다. 많은 애플리케이션에서 전환이 반드시 필요하지 않을 가능성이 높습니다.  
    논블로킹 I/O의 동작 방식(예: 단일 스레드 기반의 Node.js에서의 동시성)과 그 효과를 먼저 학습하여 논블로킹 방식의 이점을 이해하는 것이 좋은 출발점이 됩니다.

---
### **서버 지원 및 성능**

WebFlux는 Tomcat, Jetty, Netty, Undertow 등 다양한 서버에서 동작하며, 서버는 논블로킹 API로 적응됩니다. Spring Boot는 WebFlux를 간편하게 설정할 수 있도록 지원하며, 기본적으로 Netty를 사용하지만, Tomcat, Jetty 등으로 쉽게 변경할 수 있습니다.

논블로킹 웹 스택은 적은 스레드와 메모리로 확장성을 제공하며, 부하가 증가해도 예측 가능한 성능을 유지합니다. 다만, 논블로킹 방식은 요청 처리 시간이 늘어날 수 있으며, 적절한 사용 사례에서 그 장점이 극대화됩니다.

---

### 서버

Spring WebFlux는 Tomcat, Jetty, Servlet 컨테이너뿐만 아니라 Netty, Undertow와 같은 비-서블릿 런타임도 지원합니다. 모든 서버는 낮은 수준의 공통 API로 적응되어, 서버 전반에서 고수준 프로그래밍 모델을 지원할 수 있습니다.

Spring WebFlux 자체에는 서버를 시작하거나 중지하는 기능이 내장되어 있지 않습니다. 그러나 Spring 설정과 WebFlux 인프라를 조합해 몇 줄의 코드로 애플리케이션을 실행하는 것은 간단합니다.

Spring Boot는 WebFlux 시작 도구(Starter)를 제공하며, 이를 통해 위 과정을 자동화합니다. 기본적으로 이 Starter는 Netty를 사용하지만, Maven이나 Gradle 의존성을 변경해 Tomcat, Jetty, Undertow로 손쉽게 전환할 수 있습니다. Spring Boot가 기본값으로 Netty를 사용하는 이유는, Netty가 비동기 논블로킹 환경에서 더 널리 사용되고 클라이언트와 서버가 자원을 공유할 수 있기 때문입니다.

Tomcat과 Jetty는 Spring MVC와 Spring WebFlux 모두에서 사용할 수 있습니다. 그러나 사용 방식은 크게 다릅니다.

- **Spring MVC**는 서블릿 차단(Blocking) I/O에 의존하며, 필요 시 애플리케이션이 서블릿 API를 직접 사용할 수 있습니다.
- **Spring WebFlux**는 서블릿 비차단(Non-blocking) I/O에 의존하며, 낮은 수준의 어댑터를 통해 서블릿 API를 사용합니다. 이 API는 직접적으로 노출되지 않습니다.

> **참고**  
> WebFlux 애플리케이션에서 서블릿 필터를 매핑하거나 서블릿 API를 직접 조작하는 것은 권장하지 않습니다. 차단 I/O와 비차단 I/O를 동일한 컨텍스트에서 혼합하면 런타임 문제를 일으킬 수 있습니다.  
> Undertow의 경우, Spring WebFlux는 서블릿 API를 사용하지 않고 Undertow API를 직접 사용합니다.

---

### 성능

성능은 다양한 특성과 의미를 가집니다. 리액티브 및 비차단 방식은 일반적으로 애플리케이션을 더 빠르게 실행하게 만들지는 않습니다. 특정 경우(예: WebClient를 사용해 원격 호출을 병렬로 실행하는 경우) 더 빠를 수 있지만, 비차단 방식을 사용하려면 더 많은 작업이 필요하며, 이는 처리 시간이 약간 증가할 수 있습니다.

리액티브 및 비차단 방식의 주요 기대 효과는 **적은 수의 고정된 스레드와 더 적은 메모리로 확장할 수 있는 능력**입니다. 이러한 특성은 애플리케이션이 더 예측 가능한 방식으로 확장되도록 해, 높은 부하 상황에서 더 안정적으로 동작하게 만듭니다. 하지만 이러한 이점을 관찰하려면 지연 시간(느리고 예측 불가능한 네트워크 I/O 포함)이 어느 정도 있어야 합니다. 이런 상황에서 리액티브 스택은 강점을 발휘하며, 그 차이가 극적으로 나타날 수 있습니다.

---

### 동시성 모델

Spring MVC와 Spring WebFlux 모두 애너테이션 기반 컨트롤러를 지원하지만, 동시성 모델과 차단 및 스레드에 대한 기본 가정에서 핵심적인 차이가 있습니다.

- **Spring MVC (서블릿 애플리케이션 일반 포함):**  
    애플리케이션이 현재 스레드를 차단(예: 원격 호출)할 수 있다고 가정합니다. 이러한 이유로 서블릿 컨테이너는 요청 처리 중 발생할 수 있는 차단을 흡수하기 위해 큰 스레드 풀을 사용합니다.
    
- **Spring WebFlux (비차단 서버 일반 포함):**  
    애플리케이션이 차단하지 않는다고 가정합니다. 따라서 비차단 서버는 요청 처리를 위해 소규모 고정 크기 스레드 풀(이벤트 루프 워커)을 사용합니다.
    

> **TIP**  
> "확장성"과 "적은 수의 스레드"라는 개념이 모순처럼 보일 수 있지만, 현재 스레드를 절대 차단하지 않고(콜백을 사용하는 방식) 작동하면 추가 스레드가 필요하지 않습니다. 차단 호출이 없기 때문에 추가적인 스레드를 사용할 필요가 없는 것입니다.

---

### 차단 API 호출

차단 라이브러리를 반드시 사용해야 한다면 어떻게 해야 할까요?  
Reactor와 RxJava는 `publishOn` 연산자를 제공하며, 이를 통해 처리를 다른 스레드에서 계속 실행할 수 있습니다. 즉, 차단 호출을 처리하기 위한 쉬운 탈출구가 존재합니다. 그러나 차단 API는 이 동시성 모델과 적합하지 않다는 점을 항상 유념해야 합니다.

---

### 가변 상태 (Mutable State)

Reactor와 RxJava에서는 연산자를 사용해 로직을 선언합니다. 런타임 시, 데이터가 개별적인 단계를 따라 순차적으로 처리되는 리액티브 파이프라인이 형성됩니다. 이 방식의 주요 장점은, 파이프라인 내의 애플리케이션 코드가 동시에 호출되지 않기 때문에 가변 상태를 보호해야 할 필요성이 없어진다는 것입니다.

---

### 스레드 모델

Spring WebFlux 서버에서 어떤 스레드가 사용될까요?

1. **Spring WebFlux 서버 (기본 설정):**  
    데이터 액세스 또는 기타 선택적 의존성을 포함하지 않는 기본 Spring WebFlux 서버에서는 서버에 하나의 스레드와 요청 처리를 위한 몇 개의 스레드(일반적으로 CPU 코어 수만큼)가 생성됩니다.
    
2. **서블릿 컨테이너:**  
    서블릿 컨테이너(예: Tomcat)는 서블릿 차단(Blocking) I/O와 서블릿 3.1 비차단(Non-blocking) I/O를 지원하기 위해 더 많은 스레드(예: Tomcat에서 기본값 10개)로 시작할 수 있습니다.
    
3. **리액티브 WebClient:**  
    리액티브 WebClient는 이벤트 루프 방식으로 작동합니다. 따라서 WebClient와 관련된 소규모 고정 크기 스레드(예: `reactor-http-nio-` 접두어를 사용하는 Reactor Netty 커넥터 스레드)를 볼 수 있습니다.
    
    - Reactor Netty를 클라이언트와 서버 모두에 사용한다면, 기본적으로 두 환경이 이벤트 루프 자원을 공유합니다.
4. **스레드 풀(Scheduler) 추상화:**  
    Reactor와 RxJava는 `publishOn` 연산자와 함께 사용되는 스레드 풀 추상화(Scheduler)를 제공합니다.
    
    - Scheduler는 특정 동시성 전략을 나타내는 이름을 가집니다. 예를 들어:
        - `parallel`: 제한된 수의 스레드를 사용해 CPU 중심 작업 처리
        - `elastic`: 많은 스레드를 사용해 I/O 중심 작업 처리
    - 해당 스레드를 확인하면 특정 코드가 특정 스레드 풀 Scheduler 전략을 사용하고 있음을 의미합니다.
5. **데이터 액세스 라이브러리 및 서드파티 의존성:**  
    데이터 액세스 라이브러리와 기타 서드파티 의존성도 자체적으로 스레드를 생성하고 사용할 수 있습니다.
    

---

### 설정

Spring Framework 자체는 서버 시작 및 종료를 지원하지 않습니다. 서버의 스레드 모델을 구성하려면 다음 방법을 참고하세요:

1. **서버별 구성 API:**  
    사용하는 서버(Netty, Tomcat 등)의 구성 API를 통해 직접 설정합니다.
    
2. **Spring Boot 구성:**  
    Spring Boot를 사용하는 경우, 각 서버에 대한 Spring Boot 구성 옵션을 확인해 설정합니다.
    
3. **WebClient 구성:**  
    WebClient는 직접 설정할 수 있습니다.
    
4. **다른 라이브러리:**  
    기타 라이브러리는 각 라이브러리의 공식 문서를 참고해 설정합니다.