
**왜 Spring WebFlux가 만들어졌는가?**

Spring WebFlux는 소수의 스레드로 동시성을 처리하고 적은 하드웨어 자원으로 확장할 수 있는 **논블로킹 웹 스택**의 필요성에서 탄생했습니다. 서블릿의 논블로킹 I/O는 동기적(예: `getParameter`, `getPart`) 또는 블로킹(예: `Filter`, `Servlet`) 계약을 사용하는 기존 서블릿 API와 거리가 있습니다. 이에 따라 모든 논블로킹 런타임에서 사용할 수 있는 새로운 공통 API가 필요했습니다. 이는 Netty와 같은 논블로킹 환경에서 널리 사용되는 서버를 지원하기 위해 중요합니다.

다른 이유는 **함수형 프로그래밍**입니다. Java 5의 애노테이션 추가가 애노테이션 기반 REST 컨트롤러나 유닛 테스트 같은 기회를 제공했듯이, Java 8의 람다 표현식은 Java에서 함수형 API를 개발할 기회를 열었습니다. 이는 논블로킹 애플리케이션과 선언적 비동기 로직 구성을 가능하게 하는 **ReactiveX**와 **CompletableFuture** 스타일 API에 유리합니다. Java 8은 Spring WebFlux가 애노테이션 기반 컨트롤러와 함께 함수형 웹 엔드포인트를 제공할 수 있게 했습니다.

---

### **Reactive란 무엇인가?**

**논블로킹**과 **함수형**이라는 키워드 외에, Reactive의 의미는 무엇일까요?

Reactive는 변화에 반응하는 프로그래밍 모델을 뜻합니다. 네트워크 컴포넌트가 I/O 이벤트에 반응하거나, UI 컨트롤러가 마우스 이벤트에 반응하는 것처럼, **Reactive는 변화에 반응하는 것을 기반으로 합니다**. 이런 관점에서 논블로킹은 Reactive의 일종이라 할 수 있습니다. 기존 방식에서 스레드가 블로킹되었다면, 이제는 작업 완료나 데이터 가용성에 대한 알림에 반응하는 방식으로 동작합니다.

또 다른 중요한 Reactive 메커니즘은 **논블로킹 백프레셔(Back Pressure)**입니다. 동기적 명령형 코드에서는 블로킹 호출이 자연스러운 백프레셔 역할을 해 호출자가 대기하도록 강제합니다. 반면, 논블로킹 코드에서는 이벤트 발생 속도를 제어해 빠른 생산자가 데이터를 소비할 수 있는 속도를 초과하지 않도록 해야 합니다.

Reactive Streams는 Java 9에서도 채택된 작은 스펙으로, 백프레셔를 고려해 비동기 컴포넌트 간의 상호작용을 정의합니다. 예를 들어, 데이터 저장소(Publisher 역할)가 데이터를 생성하면 HTTP 서버(Subscriber 역할)가 이를 받아 응답으로 처리합니다. Reactive Streams의 주된 목적은 Subscriber가 Publisher의 데이터 생성 속도를 제어할 수 있게 하는 것입니다.

> **참고**  
> 자주 묻는 질문: Publisher가 속도를 늦출 수 없다면 어떻게 해야 하나요?  
> Reactive Streams는 메커니즘과 경계를 설정하는 데 목적이 있습니다. Publisher가 속도를 늦출 수 없는 경우 버퍼링, 데이터 드롭, 또는 실패 처리 방식을 선택해야 합니다.

---

### **Reactive API**

Reactive Streams는 [[상호 운용성]]을 위해 중요합니다. 이는 라이브러리와 인프라 컴포넌트에 유용하지만, 애플리케이션 API로는 너무 저수준이어서 적합하지 않습니다. 애플리케이션에서는 Java 8의 `Stream` API와 유사하지만 컬렉션에 국한되지 않은 고수준의 [[함수형 API]]가 필요합니다. Reactive 라이브러리는 이러한 요구를 해결합니다.

Spring WebFlux에서 선택한 Reactive 라이브러리는 **Reactor**입니다. Reactor는 `Mono`와 `Flux`라는 API 타입을 제공해 각각 0~1개(`Mono`), 0~N개(`Flux`)의 데이터 시퀀스를 처리합니다. 이 API는 ReactiveX의 연산자 어휘에 맞춰 설계된 풍부한 연산자를 지원합니다. Reactor는 Reactive Streams 라이브러리로, 모든 연산자가 [[논블로킹 백프레셔]]를 지원합니다. Reactor는 서버 측 Java에 초점을 맞춰 개발되었으며 Spring과 긴밀히 협력하여 발전해 왔습니다.

WebFlux는 Reactor를 핵심 의존성으로 사용하지만, Reactive Streams를 통해 다른 Reactive 라이브러리와도 상호 운용됩니다. 일반적으로 WebFlux API는 `Publisher`를 입력으로 받아 내부적으로 Reactor 타입으로 변환한 뒤, `Mono` 또는 `Flux`로 반환합니다. 따라서, 어떤 `Publisher`도 입력으로 전달할 수 있고 출력에서 연산을 적용할 수 있지만, 다른 Reactive 라이브러리를 사용할 경우 출력 값을 변환해야 합니다. 애노테이션 기반 컨트롤러 같은 경우 WebFlux는 RxJava나 다른 Reactive 라이브러리의 사용을 자동으로 처리합니다. 자세한 내용은 [Reactive Libraries](https://spring.io/)를 참고하십시오.

> **참고**  
> Reactive API 외에도 WebFlux는 Kotlin의 Coroutines API와 함께 사용할 수 있습니다. 이는 더 명령형 스타일의 프로그래밍을 제공합니다. 다음 예제는 Coroutines API를 사용하는 Kotlin 코드 샘플을 포함합니다.

---

### **프로그래밍 모델**

Spring WebFlux는 다음 두 가지 프로그래밍 모델을 제공합니다.

1. **애노테이션 컨트롤러**:  
    Spring MVC와 일관성을 유지하며, `spring-web` 모듈의 동일한 애노테이션(@RequestBody 등)을 기반으로 합니다. Spring MVC와 WebFlux 컨트롤러 모두 Reactive 리턴 타입(Reactor 및 RxJava)을 지원하므로, 두 모델을 구분하기 쉽지 않을 수 있습니다. 그러나 WebFlux는 Reactive 매개변수도 지원한다는 점에서 차이가 있습니다.
    
2. **[[함수형 엔드포인트]]**:  
    람다 기반으로 경량화된 함수형 프로그래밍 모델입니다. 이는 요청을 라우팅하고 처리하기 위해 애플리케이션이 사용할 수 있는 유틸리티 집합으로 볼 수 있습니다. 애노테이션 컨트롤러와의 주요 차이는, 함수형 엔드포인트에서는 요청 처리를 처음부터 끝까지 애플리케이션이 제어한다는 점입니다.
    

---

### **적용 사례**

**Spring MVC와 WebFlux 중 무엇을 선택해야 할까요?**

자연스러운 질문이지만, 이는 잘못된 이분법을 전제합니다. 사실 이 두 가지는 서로 협력해 사용 가능한 옵션의 범위를 확장합니다. 
Spring MVC와 WebFlux는 서로 간의 연속성과 일관성을 고려해 설계되었으며, 동시에 사용할 수 있습니다.  또한, 각 방식에서 얻은 피드백은 서로에게 이점을 제공합니다. 
아래 다이어그램은 이 두 기술 간의 관계, 공통점, 그리고 각 기술이 고유하게 지원하는 기능을 보여줍니다:

![[Pasted image 20250121163258.png]]

- **Spring MVC 애플리케이션이 잘 동작하고 있다면 변경할 필요가 없습니다.**  
    명령형 프로그래밍은 코드를 작성하고 이해하며 디버깅하기 가장 쉬운 방법입니다. 또한, 대부분의 라이브러리가 기존에 차단(Blocking) 방식으로 개발되었기 때문에, 선택할 수 있는 라이브러리의 범위가 가장 넓습니다.
    
- **논블로킹 웹 스택을 고려하고 있다면 Spring WebFlux를 선택하세요.**  
    Spring WebFlux는 이 영역의 다른 프레임워크들과 동일한 실행 모델의 이점을 제공하며, 서버(Netty, Tomcat, Jetty, Undertow, Servlet 컨테이너), 프로그래밍 모델(애너테이션 기반 컨트롤러, 함수형 웹 엔드포인트), 리액티브 라이브러리(Reactor, RxJava 등)를 선택할 수 있는 유연성을 제공합니다.
    
- **Java 8 람다나 Kotlin을 활용한 경량의 함수형 웹 프레임워크를 찾고 있다면,**  
    Spring WebFlux의 함수형 웹 엔드포인트를 사용할 수 있습니다. 이 접근 방식은 간단한 애플리케이션이나 복잡한 요구사항이 없는 마이크로서비스에 적합하며, 투명성과 제어성을 높이는 데 유리합니다.
    
- **마이크로서비스 아키텍처에서는 Spring MVC와 Spring WebFlux를 혼합해 사용할 수 있습니다.**  
    Spring MVC 컨트롤러, Spring WebFlux 컨트롤러 또는 Spring WebFlux 함수형 엔드포인트를 조합하여 활용할 수 있습니다. 두 프레임워크가 동일한 애너테이션 기반 프로그래밍 모델을 지원하기 때문에 지식을 재활용하면서도 각 작업에 적합한 도구를 선택하기 용이합니다.
    
- **애플리케이션의 의존성을 확인하여 적합한 선택을 평가하세요.**  
    차단 방식의 영속성 API(JPA, JDBC)나 네트워킹 API를 사용하는 경우, Spring MVC가 일반적인 아키텍처에서 최적의 선택입니다. 기술적으로는 Reactor나 RxJava를 사용해 별도 스레드에서 차단 호출을 수행할 수 있지만, 이는 논블로킹 웹 스택의 장점을 제대로 활용하지 못하는 방식입니다.
    
- **Spring MVC 애플리케이션에서 원격 서비스를 호출하는 경우, 리액티브 WebClient를 활용해 보세요.**  
    Spring MVC 컨트롤러 메서드에서 리액티브 타입(Reactor, RxJava 등)을 직접 반환할 수 있습니다. 호출당 지연 시간이 크거나 호출 간 상호 의존성이 높을수록 리액티브 WebClient의 이점이 더 두드러집니다. 또한, Spring MVC 컨트롤러에서 다른 리액티브 구성 요소를 호출할 수도 있습니다.
    
- **큰 팀의 경우, 논블로킹, 함수형, 선언형 프로그래밍으로 전환하는 데 급격한 학습 곡선을 고려하세요.**  
    완전한 전환 없이 리액티브 WebClient를 먼저 사용하는 것이 실용적인 시작점입니다. 그 이후로는 작은 규모에서 시작해 점진적으로 효과를 측정하는 방식이 좋습니다. 많은 애플리케이션에서 전환이 반드시 필요하지 않을 가능성이 높습니다.  
    논블로킹 I/O의 동작 방식(예: 단일 스레드 기반의 Node.js에서의 동시성)과 그 효과를 먼저 학습하여 논블로킹 방식의 이점을 이해하는 것이 좋은 출발점이 됩니다.

---

### **서버 지원 및 성능**

WebFlux는 Tomcat, Jetty, Netty, Undertow 등 다양한 서버에서 동작하며, 서버는 논블로킹 API로 적응됩니다. Spring Boot는 WebFlux를 간편하게 설정할 수 있도록 지원하며, 기본적으로 Netty를 사용하지만, Tomcat, Jetty 등으로 쉽게 변경할 수 있습니다.

논블로킹 웹 스택은 적은 스레드와 메모리로 확장성을 제공하며, 부하가 증가해도 예측 가능한 성능을 유지합니다. 다만, 논블로킹 방식은 요청 처리 시간이 늘어날 수 있으며, 적절한 사용 사례에서 그 장점이 극대화됩니다.

