
**왜 Spring WebFlux가 만들어졌는가?**

Spring WebFlux는 소수의 스레드로 동시성을 처리하고 적은 하드웨어 자원으로 확장할 수 있는 **논블로킹 웹 스택**의 필요성에서 탄생했습니다. 서블릿의 논블로킹 I/O는 동기적(예: `getParameter`, `getPart`) 또는 블로킹(예: `Filter`, `Servlet`) 계약을 사용하는 기존 서블릿 API와 거리가 있습니다. 이에 따라 모든 논블로킹 런타임에서 사용할 수 있는 새로운 공통 API가 필요했습니다. 이는 Netty와 같은 논블로킹 환경에서 널리 사용되는 서버를 지원하기 위해 중요합니다.

다른 이유는 **함수형 프로그래밍**입니다. Java 5의 애노테이션 추가가 애노테이션 기반 REST 컨트롤러나 유닛 테스트 같은 기회를 제공했듯이, Java 8의 람다 표현식은 Java에서 함수형 API를 개발할 기회를 열었습니다. 이는 논블로킹 애플리케이션과 선언적 비동기 로직 구성을 가능하게 하는 **ReactiveX**와 **CompletableFuture** 스타일 API에 유리합니다. Java 8은 Spring WebFlux가 애노테이션 기반 컨트롤러와 함께 함수형 웹 엔드포인트를 제공할 수 있게 했습니다.

---

### **Reactive란 무엇인가?**

**논블로킹**과 **함수형**이라는 키워드 외에, Reactive의 의미는 무엇일까요?

Reactive는 변화에 반응하는 프로그래밍 모델을 뜻합니다. 네트워크 컴포넌트가 I/O 이벤트에 반응하거나, UI 컨트롤러가 마우스 이벤트에 반응하는 것처럼, Reactive는 변화에 반응하는 것을 기반으로 합니다. 이런 관점에서 논블로킹은 Reactive의 일종이라 할 수 있습니다. 기존 방식에서 스레드가 블로킹되었다면, 이제는 작업 완료나 데이터 가용성에 대한 알림에 반응하는 방식으로 동작합니다.

또 다른 중요한 Reactive 메커니즘은 **논블로킹 백프레셔(Back Pressure)**입니다. 동기적 명령형 코드에서는 블로킹 호출이 자연스러운 백프레셔 역할을 해 호출자가 대기하도록 강제합니다. 반면, 논블로킹 코드에서는 이벤트 발생 속도를 제어해 빠른 생산자가 데이터를 소비할 수 있는 속도를 초과하지 않도록 해야 합니다.

Reactive Streams는 Java 9에서도 채택된 작은 스펙으로, 백프레셔를 고려해 비동기 컴포넌트 간의 상호작용을 정의합니다. 예를 들어, 데이터 저장소(Publisher 역할)가 데이터를 생성하면 HTTP 서버(Subscriber 역할)가 이를 받아 응답으로 처리합니다. Reactive Streams의 주된 목적은 Subscriber가 Publisher의 데이터 생성 속도를 제어할 수 있게 하는 것입니다.

> **참고**  
> 자주 묻는 질문: Publisher가 속도를 늦출 수 없다면 어떻게 해야 하나요?  
> Reactive Streams는 메커니즘과 경계를 설정하는 데 목적이 있습니다. Publisher가 속도를 늦출 수 없는 경우 버퍼링, 데이터 드롭, 또는 실패 처리 방식을 선택해야 합니다.

---

### **Reactive API**

Reactive Streams는 상호 운용성을 위해 중요합니다. 이는 라이브러리와 인프라 컴포넌트에 유용하지만, 애플리케이션 API로는 너무 저수준이어서 적합하지 않습니다. 애플리케이션에서는 Java 8의 `Stream` API와 유사하지만 컬렉션에 국한되지 않은 고수준의 함수형 API가 필요합니다. Reactive 라이브러리는 이러한 요구를 해결합니다.

Spring WebFlux에서 선택한 Reactive 라이브러리는 **Reactor**입니다. Reactor는 `Mono`와 `Flux`라는 API 타입을 제공해 각각 0~~1개(`Mono`), 0~~N개(`Flux`)의 데이터 시퀀스를 처리합니다. 이 API는 ReactiveX의 연산자 어휘에 맞춰 설계된 풍부한 연산자를 지원합니다. Reactor는 Reactive Streams 라이브러리로, 모든 연산자가 논블로킹 백프레셔를 지원합니다. Reactor는 서버 측 Java에 초점을 맞춰 개발되었으며 Spring과 긴밀히 협력하여 발전해 왔습니다.

WebFlux는 Reactor를 핵심 의존성으로 사용하지만, Reactive Streams를 통해 다른 Reactive 라이브러리와도 상호 운용됩니다. 일반적으로 WebFlux API는 `Publisher`를 입력으로 받아 내부적으로 Reactor 타입으로 변환한 뒤, `Mono` 또는 `Flux`로 반환합니다. 따라서, 어떤 `Publisher`도 입력으로 전달할 수 있고 출력에서 연산을 적용할 수 있지만, 다른 Reactive 라이브러리를 사용할 경우 출력 값을 변환해야 합니다. 애노테이션 기반 컨트롤러 같은 경우 WebFlux는 RxJava나 다른 Reactive 라이브러리의 사용을 자동으로 처리합니다. 자세한 내용은 [Reactive Libraries](https://spring.io/)를 참고하십시오.

> **참고**  
> Reactive API 외에도 WebFlux는 Kotlin의 Coroutines API와 함께 사용할 수 있습니다. 이는 더 명령형 스타일의 프로그래밍을 제공합니다. 다음 예제는 Coroutines API를 사용하는 Kotlin 코드 샘플을 포함합니다.

---

### **프로그래밍 모델**

Spring WebFlux는 다음 두 가지 프로그래밍 모델을 제공합니다.

1. **애노테이션 컨트롤러**:  
    Spring MVC와 일관성을 유지하며, `spring-web` 모듈의 동일한 애노테이션(@RequestBody 등)을 기반으로 합니다. Spring MVC와 WebFlux 컨트롤러 모두 Reactive 리턴 타입(Reactor 및 RxJava)을 지원하므로, 두 모델을 구분하기 쉽지 않을 수 있습니다. 그러나 WebFlux는 Reactive 매개변수도 지원한다는 점에서 차이가 있습니다.
    
2. **함수형 엔드포인트**:  
    람다 기반으로 경량화된 함수형 프로그래밍 모델입니다. 이는 요청을 라우팅하고 처리하기 위해 애플리케이션이 사용할 수 있는 유틸리티 집합으로 볼 수 있습니다. 애노테이션 컨트롤러와의 주요 차이는, 함수형 엔드포인트에서는 요청 처리를 처음부터 끝까지 애플리케이션이 제어한다는 점입니다.
    

---

### **적용 사례**

**Spring MVC와 WebFlux 중 무엇을 선택해야 할까요?**

이 질문은 잘못된 양자택일을 만들 수 있습니다. 사실 두 기술은 서로를 보완하며 함께 사용할 수 있습니다. 두 모델은 일관성과 지속성을 고려해 설계되었으며, 서로의 피드백을 통해 발전해왔습니다.

다음은 선택 시 고려할 몇 가지 포인트입니다.

![[Pasted image 20250121163258.png]]

- Spring MVC 애플리케이션이 잘 동작한다면 변경할 필요가 없습니다. 명령형 프로그래밍은 코드 작성, 이해, 디버깅이 가장 쉽고, 대부분의 라이브러리가 블로킹 방식을 지원합니다.
- 논블로킹 웹 스택을 고려 중이라면, Spring WebFlux는 이 분야의 다른 프레임워크와 동일한 실행 모델 이점을 제공하며 Netty, Tomcat, Jetty 등 다양한 서버와 프로그래밍 모델(애노테이션 기반 컨트롤러, 함수형 엔드포인트), 그리고 Reactor, RxJava와 같은 다양한 Reactive 라이브러리를 선택할 수 있습니다.
- Java 8 람다나 Kotlin과 함께 사용할 경량화된 함수형 웹 프레임워크가 필요하다면, WebFlux 함수형 엔드포인트를 사용할 수 있습니다. 소규모 애플리케이션이나 마이크로서비스에 적합합니다.
- 마이크로서비스 아키텍처에서는 Spring MVC 컨트롤러, WebFlux 컨트롤러, 함수형 엔드포인트를 혼합해 사용할 수 있습니다.

---

### **서버 지원 및 성능**

WebFlux는 Tomcat, Jetty, Netty, Undertow 등 다양한 서버에서 동작하며, 서버는 논블로킹 API로 적응됩니다. Spring Boot는 WebFlux를 간편하게 설정할 수 있도록 지원하며, 기본적으로 Netty를 사용하지만, Tomcat, Jetty 등으로 쉽게 변경할 수 있습니다.

논블로킹 웹 스택은 적은 스레드와 메모리로 확장성을 제공하며, 부하가 증가해도 예측 가능한 성능을 유지합니다. 다만, 논블로킹 방식은 요청 처리 시간이 늘어날 수 있으며, 적절한 사용 사례에서 그 장점이 극대화됩니다.