
## 동기/비동기 &블로킹/논블로킹의 차이
**동기/비동기**가 전체적인 작업에 대한 **순차적인 흐름 유무**라면, **블로킹/논블로킹**은 전체적인 작업의 **흐름 자체를 막냐 안 막냐**로 볼 수 있는 것이다. 예를 들어, 파일을 읽는 작업이 있을 때, 블로킹 방식으로 읽으면 파일을 다 읽을 때까지 대기하고, 논블로킹 방식으로 읽으면 파일을 다 읽지 않아도 다른 작업을 할 수 있다. 

출처: [https://inpa.tistory.com/entry/👩‍💻-동기비동기-블로킹논블로킹-개념-정리#동기synchronous_/_비동기asynchronous](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC#%EB%8F%99%EA%B8%B0synchronous_/_%EB%B9%84%EB%8F%99%EA%B8%B0asynchronous) [Inpa Dev 👨‍💻:티스토리]

## 동기/비동기 & 블로킹/논블로킹 기술 예시

#### 1. 동기 + 블로킹

- **HTTP 요청 (일반적인 경우):** 웹 브라우저에서 웹 페이지를 요청하면, 요청에 대한 응답을 받을 때까지 브라우저는 다른 작업을 수행하지 못하고 기다립니다. (동기) 또한, 요청을 처리하는 동안 현재 스레드가 점유되어 다른 요청을 처리하지 못합니다. (블로킹)
- **JDBC (Java Database Connectivity):** 데이터베이스에 쿼리를 보내고 결과를 받을 때까지 애플리케이션은 대기합니다. (동기) 쿼리 실행 중에는 해당 스레드가 다른 작업을 처리할 수 없습니다. (블로킹)

#### 2. 동기 + 논블로킹

- **Node.js (이벤트 루프 기반):** Node.js는 단일 스레드 이벤트 루프를 사용하여 여러 클라이언트 요청을 처리합니다. 각 요청은 논블로킹 방식으로 처리되므로, 하나의 요청이 I/O 작업으로 인해 대기 중이더라도 다른 요청을 처리할 수 있습니다. 하지만, 각 요청 내부에서는 작업이 순차적으로 처리됩니다. (동기)
- **NIO (New Input/Output):** 자바 NIO는 논블로킹 I/O 작업을 지원하여, 여러 채널에서 동시에 데이터를 읽고 쓸 수 있습니다. 하지만, 각 채널에서의 작업은 순차적으로 처리됩니다. (동기)

#### 3. 비동기 + 블로킹

- **AJAX (Asynchronous JavaScript and XML):** 웹 페이지에서 서버에 비동기적으로 데이터를 요청하고, 응답을 받으면 페이지를 동적으로 업데이트합니다. (비동기) 하지만, AJAX 요청 자체는 블로킹 방식으로 처리될 수 있습니다.
- **퓨처(Future)와 콜백(Callback):** 자바의 Future 객체는 비동기 작업의 결과를 나타내며, 작업이 완료되면 콜백 함수를 통해 결과를 처리합니다. (비동기) 하지만, 콜백 함수 내부에서는 작업이 순차적으로 처리됩니다. (블로킹)

#### 4. 비동기 + 논블로킹

- **Netty (이벤트 기반 네트워크 프레임워크):** Netty는 비동기 논블로킹 방식으로 네트워크 통신을 처리합니다. 이벤트 기반 모델을 사용하여 적은 수의 스레드로 많은 연결을 효율적으로 관리하며, 각 연결에서의 작업은 비동기적으로 처리됩니다.
- **RxJava (Reactive Extensions for Java):** RxJava는 리액티브 프로그래밍 라이브러리로, 비동기 데이터 스트림을 처리하는 데 사용됩니다. Observable 객체를 통해 데이터를 비동기적으로 발행하고, Observer 객체를 통해 데이터를 비동기적으로 처리합니다.


|   |   |   |
|---|---|---|
|방식|설명|예시|
|동기 + 블로킹|작업 요청 후 결과를 기다리며, 현재 스레드를 점유하여 다른 작업을 막음|HTTP 요청 (일반적인 경우), JDBC|
|동기 + 논블로킹|작업 요청 후 즉시 제어 흐름을 반환하지만, 각 작업 내부에서는 순차적으로 처리됨|Node.js, NIO|
|비동기 + 블로킹|작업 요청 후 결과를 기다리지 않고 다음 작업으로 넘어가지만, 콜백 함수 내부에서는 작업이 순차적으로 처리됨|AJAX, 퓨처(Future)와 콜백(Callback)|
|비동기 + 논블로킹|작업 요청 후 결과를 기다리지 않고 다음 작업으로 넘어가며, 각 작업은 독립적으로 비동기적으로 처리됨|Netty, RxJava|

## 블로킹 I/O특징 
- Bloacking I/O는 작업 스레드의 작업이 종료될 때 까지 요청 스레드를 차단한다.
- 스레드가 차단되는 문제를 보완하기 위해 **멀트스레딩 기법을 사용**할 수 있다.
- 멀티스레딩 기법 사용 시 컨텍스트 스위칭 전환 비용, 메모리 사용 오버헤드, 스레드 풀의 응답 지연 등의 문제가 발생할 수 있다.
## 논-블로킹 I/O 특징
- 작업 스레드의 종료 여부와 관계없이 요청 스레드가  차단되지 않는다.
- 적은 수의 스레드만 사용해 스레드 전환비용이 적으므로, CPU를 효율적으로 사용할 수 있다.
- **CPU를 많이 사용하는 작업**의 경우에는 성능에 악영향을 미칠 수 있다.
- 사용자 요청 처리에서 응답까지 전 과정이 Non-Blocking 이어야 제대로 된 효과를 얻을 수 있다.